import spacy
#subj-like
subjects = ["nsubj", "nsubjpass", "csubj", "csubjpass", "expl", "subj", "agent"] #"agent", "expl", "subj"]
objects = ["dobj", "attr", "oprd", "iobj", "pobj", "obj"] #"dative",
mods = ["nummod", "amod", "nmod", "advmod", "npmod", "npadvmod", "quantmod"]
edge_types = { "nsubj":[], "nsubjpass":[], "csubj":[], "csubjpass":[], "agent":[], "expl":[],\
         "dobj": [], "dative": [], "attr":[], "oprd":[], "iobj":[], "pobj":[],\
         "ccomp":[], "xcomp":[], "acomp":[],\
         "appos":[], "acl":[], "relcl":[], "det":[], "predet":[], "nummod":[], "amod":[], "poss":[], "nmod":[], "npadvmod":[], "quantmod":[],\
         "advmod":[], "advcl":[], "neg":[], "npmod":[], "pobj":[], "pcomp":[],\
         "conj":[], "cc":[], "preconj":[], "prep":[],\
         "aux":[], "auxpass":[], "compound":[], "prt":[], "case":[], "mark":[],\
         "det":[], "meta":[], "paratxis":[], "punct":[], "root":[],\
         "mod":[], "obj":[], "subj":[], "":[], "dep":[], "parataxis":[], "intj":[]}

class Node:
    #parent -dep-> node(text,pos_tag) ->children
     def __init__(self, parent, dep, text, pos_tag, index):
         self.parent = parent #parent Node
         self.dep = dep #dependency relation to parent
         self.text = text #node text
         self.pos_tag = pos_tag
         self.children = [] #children Nodes
         self.affliation = []
         self.coIndex = []
         self.position = -1
         self.index = index

class Tree:

    #parent -child.dep-> child
    def __init__(self, root):
        self.root = root
        self.verb = [] #list of verbs in tree, later to become verb phrases

    # create a copy of the dep tree
    #
    # @param node: token generated by spaccy
    # @param copy: Node copy of token
    def createTree(self, node, copy):
        if node.pos_ == "VERB" or node.pos_ == "AUX":
            self.verb.append(copy)
        for child in node.children:
            new_node = Node(copy, child.dep_, child.text, child.pos_, (child.i,child.i))
            copy.children.append(new_node)
            self.createTree(child, new_node)

    # writes tree to file
    #
    # @param tf: string file path
    def levelTraversal(self, tf):

        frontier=[self.root]

        tf.write(self.root.dep + "\n" + self.root.text + "\n")
        next_level = list()
        for n in frontier:
            for child in n.children:
                next_level.append(child)
        frontier = next_level

        while frontier:
            tf.write(' '.join(node.dep + "(" + node.pos_tag + ")" for node in frontier))
            tf.write("\n")
            tf.write(' '.join(node.text + "(" + node.parent.text + ")" for node in frontier))
            tf.write("\n")

            next_level = list()
            for n in frontier:
                for child in n.children:
                    next_level.append(child)
            frontier = next_level

    # writes object to file
    #
    # @param f: string file path
    # @param verbNode: Node node of verb
    # @param tree_write: bool whether to write to file
    # @ret tuple of subject span positions
    def getObjects(self, f, verbNode, tree_write):
        frontier = []
        left, right = (1000, -1)
        for n in verbNode.children:
            if n.dep == "obj":
                frontier.append(n)
                left, right = n.index

        phrase = " "
        while frontier:
            if tree_write:
                f.write(' '.join(node.dep for node in frontier))
                f.write("\n")
                f.write(' '.join(node.text + "(" + node.parent.text + ")" for node in frontier))
                f.write("\n")

            next_level = list()
            for n in frontier:
                for child in n.children:
                    next_level.append(child)
                    if child.index[0] < left:
                        left = child.index[0]
                    if child.index[1] > right:
                        right = child.index[1]
            frontier = next_level
        return (left, right)

    # writes subject to file
    #
    # @param f: string file path
    # @param verbNode: Node node of verb
    # @param tree_write: bool whether to write to file
    # @ret tuple of subject span positions
    def getSubjects(self, f, verbNode, tree_write):
        frontier = []
        left, right = (1000, -1)
        for n in verbNode.children:
            if n.dep == "subj":
                frontier.append(n)
                left, right = n.index

        while frontier:
            if tree_write:
                f.write(' '.join(node.dep for node in frontier))
                f.write("\n")
                f.write(' '.join(node.text + "(" + node.parent.text + ")" for node in frontier))
                f.write("\n")

            next_level = list()
            for n in frontier:
                for child in n.children:
                    next_level.append(child)
                    if child.index[0] < left:
                        left = child.index[0]
                    if child.index[1] > right:
                        right = child.index[1]
            frontier = next_level
        return (left, right)

    # @ret bool if sentence contains negation
    def check_negation(self, verbNode):
        for child in verbNode.children:
            if child.dep == "neg":
                return True
        #check negation for obj/ subj
        for child in verbNode.children:
            if child.dep == "obj" or child.dep == "subj":
                for child_child in child.children:
                    if child_child.text == "no" or child_child.text=="No":
                        return True
        return False

    ################################
    # unused functions
    ################################
    # @ret bool if root has object child
    def has_obj(self, node):
        for child in node.children:
            if child.dep in objects or child.dep == "obj":
                return True
        return False

    # @ret bool if root has subject child
    def has_subj(self, node):
        for child in node.children:
            if child.dep in subjects or child.dep == "subj":
                return True
        return False

    # @ret tuple (start_position, end_position) of an object phrase
    def getObjects_phrase(self, verbNode):
        frontier = []
        left = right = -1
        for n in verbNode.children:
            if n.dep == "obj":
                frontier.append(n)
                left = n.index[0]
                right = n.index[1]

        while frontier:
            next_level = list()
            for n in frontier:
                for child in n.children:
                    right = child.index[1] if child.index[1] > right else right
                    left = child.index[0] if child.index[0] < left else left
                    next_level.append(child)
            frontier = next_level
        return (left,right)

    # @ret tuple (start_position, end_position) of a subject phrase
    def getSubjects_phrase(self, verbNode):
        frontier = []
        left = right = -1
        for n in verbNode.children:
            if n.dep == "subj":
                frontier.append(n)
                left = n.index[0]
                right = n.index[1]

        while frontier:
            next_level = list()
            for n in frontier:
                for child in n.children:
                    right = child.index[1] if child.index[1] > right else right
                    left = child.index[0] if child.index[0] < left else left
                    next_level.append(child)
            frontier = next_level
        return (left,right)



